<?xml version="1.0"
      encoding="utf-8"
?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<title>The Aseba Language</title>
<meta name="generator" content="http://txt2tags.sf.net" />
</head>
<body bgcolor="white" text="black">
<div align="center">
<h1>The Aseba Language</h1>
<h2>St√©phane Magnenat</h2>
</div>

<p>
The aseba programming language aims at supporting the distributed control facilities that aseba provides.
Syntactically, this language resembles <i>matlab</i>; this similarity allows developers with previous knowledge of some scripting language to feel quickly at ease with aseba and thus lowers the learning curve.
Semantically, it is a simple imperative programming language with a single basic type (16 bit signed integers) and arrays.
This simplicity allows developers to program behaviours with no prior knowledge of a type system, integers being the most natural type of variables and well suited for programming microcontroller-based mobile robots.
</p>
<h1>Variables</h1>
<p>
Variables refer either to single scalar values or to arrays of scalar values.
The values are comprised between -32768 and 32767, which is the range of 16 bit signed integers.
You can access arrays elements using the usual square parenthesis operator; arrays indexes begin at zero.
You must declare all user-defined variables at the top of the aseba script before doing any processing.
For instance:
</p>
<pre>
  var a
  var c[10]
  var b = 0
  var d[3] = 2, 3, 4
</pre>
<p></p>
<h1>Events</h1>
<p>
Aseba is an <i>event-based</i> architecture, which means that events trigger code execution asynchronously.
Events can be external, for instance a user-defined event coming from another aseba node, or internal, for instance emitted by a sensor which provides updated data.
The reception of an event executes, if defined, the block of code that begins with the <code>onevent</code> keyword followed by the name of the event; the code at the top of the script is executed when the script is started or reset.
The script can also send events by using the <code>emit</code> keyword, followed by the name of the variable to send, if any.
If a variable is provided, the size of the event must match the size of the argument to emit.
Events allow the script to trigger the execution of code on another node or to communicate with an external program.
</p>
<p>
To allow the execution of related code upon new events, scripts must not block and thus not contain any infinite loop.
For instance in the context of robotics, where a traditional robot control program would do some processing inside an infinite loop, an aseba script would just do the processing inside a sensor-related event.
For instance:
</p>
<pre>
  var run = 0
  
  onevent start
  run = 1
  
  onevent stop
  run = 0
  
  onevent ir_sensors
  if run == 1 then
  	emit sensors_values proximity_sensors_values
  end
</pre>
<p></p>
<h1>Expressions and Assignations</h1>
<p>
Expressions allow mathematical computations and are written using the normal mathematical infix syntax.
Assignations use the keyword <code>=</code> and set the result of the computation of an expression to a scalar variable or to an array element.
Aseba provides, by order of precedence, the operators <code>*</code>, <code>/</code>, <code>%</code> (modulo); followed by <code>+</code> and <code>-</code>; followed by <code>&lt;&lt;</code> (left shift) and <code>&gt;&gt;</code> (right shift).
To evaluate an expression in a different order, you can use a pair of parenthesis to group a sub-expression.
For instance:
</p>
<pre>
  a = 1 + 1
  b = b + d[0]
  b = (a - 7) % 5
  c[a] = d[a]
</pre>
<p></p>
<h1>Conditionals</h1>
<p>
Aseba provides two types of conditionals: <code>if</code> and <code>when</code>.
Comparison operators are <code>==</code>, <code>!=</code>, <code>&gt;</code>, <code>&gt;=</code>, <code>&lt;</code>, and <code>&lt;=</code>; comparisons can be grouped by using the <code>and</code>, <code>or</code>, and <code>not</code> operators, and by using parenthesis.
</p>
<p>
Both <code>if</code> and <code>when</code> execute a different block of code whether a condition is true or false; but <code>when</code> executes the block corresponding to true only if the last evaluation of the condition was false and the current is true.
This allows the execution of code only when something changes.
For instance:
</p>
<pre>
  if a - b &gt; c[0] then
  	c[0] = a
  else
  	b = 0
  end
  when a &gt; b do
  	leds[0] = 1
  end
</pre>
<p>
Here <code>when</code> evaluates to true only when <code>a</code> <i>becomes</i> bigger than <code>b</code>.
</p>
<h1>Loops</h1>
<p>
Two constructs allow the creation of loops: <code>while</code> and <code>for</code>.
</p>
<p>
A <code>while</code> loop repeatedly executes a block of code as long as the condition is true.
The condition is of the same form as the one <code>if</code> uses.
For instance:
</p>
<pre>
  while i &lt; 10 do
  	v = v + i * i
  	i = i + 1
  end
</pre>
<p></p>
<p>
A <code>for</code> loop allows a variable to iterate over a range of integers, with an optional step size.
For instance:
</p>
<pre>
  for i in 1:10 do
  	v = v + i * i
  end
  for i in 30:1 step -3 do
  	v = v - i * i
  end
</pre>
<p></p>
<h1>Subroutines</h1>
<p>
When you perform the same operation at two or more different places in the code, you can write the common code only once in a subroutine and then call this subroutine.
You define a subroutine using the <code>sub</code> keyword followed by the name of the subroutine and call the subroutine using the <code>callsub</code> keyword, also followed by the name of the subroutine.
Subroutines cannot have arguments, nor be recursive, either directly or indirectly.
Subroutines can access any variable.
For instance:
</p>
<pre>
  var v = 0
  
  sub toto
  v = 1
  
  onevent test
  callsub toto
</pre>
<p></p>
<h1>Natives Functions</h1>
<p>
We designed aseba script to be simple to allow a quick understanding even by novice developers and to implement the virtual machine efficiently on a microcontroller.
To perform complex or resource consuming processing, we provide native functions that are implemented in native code for efficient execution.
For instance, a native function is the natural way to implement a scalar product.
</p>
<p>
Native functions are safe, as they specify and check the size of their arguments, which can be constants, variables, or array accesses.
In the latter, you can access the whole array, a single element, or a sub-range of the array.
Native functions take their arguments as reference and can modify their contents but do not return any value.
You can use native functions through the <code>call</code> keyword.
For instance:
</p>
<pre>
  var a[3] = 1, 2, 3
  var b[3] = 2, 3, 4
  var c[5] = 5, 10, 15
  var d
  call math.dot(d, a, b, 3)
  call math.dot(d, a, c[0:2], 3)
  call math.dot(a[0], c[0:2], 3)
</pre>
<p></p>
<h1>Comments</h1>
<p>
Comments begin with a <i>#</i> and terminate at the end of the line.
For instance:
</p>
<pre>
  # this is a comment
  var b	# another comment
</pre>

<!-- xhtml code generated by txt2tags 2.3 (http://txt2tags.sf.net) -->
<!-- cmdline: txt2tags -t xhtml -i docsource/language/aseba-language.en.t2t -o studio/doc/aseba-language.en.html -->
</body></html>
