<!DOCTYPE aesl-source>
<network>


<!--list of global events-->
<event size="2" name="ObstacleDetected" />
<event size="0" name="FreeOfObstacle" />


<!--list of constants-->


<!--source code of node left motor-->
<node name="left motor" >speed = 300

onevent ObstacleDetected
speed = 300 + (args[0] + args[1]) * 4

onevent FreeOfObstacle
speed = 300
</node>


<!--source code of node right motor-->
<node name="right motor" >speed = 300

onevent ObstacleDetected
speed = 300 + (args[0] - args[1]) * 4

onevent FreeOfObstacle
speed = 300</node>


<!--source code of node proximity sensors-->
<node name="proximity sensors" ># angles = pi/48:pi/12:(47*2*pi)/48
# vectorX = round(-cos(angles)*255)
# vectorY = round(-sin(angles)*255)

# vector field obstacle avoidance
var vectorX[24] = -254, -241, -212, -168, -113,  -50, 17, 82, 142, 192, 229, 250, 254, 241, 212,  168, 113, 50, -17, -82, -142, -192, -229, -250
var vectorY[24] = -17, -82, -142, -192, -229, -250, -254, -241, -212, -168, -113, -50, 17, 82  , 142, 192, 229, 250, 254, 241, 212, 168, 113, 50
var threshold = 100
var eventBuffer[2]

var activation

onevent timer

call math.dot(eventBuffer[0], bumpers, vectorX, 11)
call math.dot(eventBuffer[1], bumpers, vectorY, 11)
call math.dot(activation, eventBuffer, eventBuffer, 0)

if activation > threshold then
	emit ObstacleDetected eventBuffer
end
when activation &lt;= threshold do
	emit FreeOfObstacle
end
	</node>


<!--source code of node distance sensors-->
<node name="distance sensors" ></node>


</network>
